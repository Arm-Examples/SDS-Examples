# About this application

This is a standalone test application that uses [SDS Recorder](https://github.com/ARM-software/SDS-Framework)
to record test input and output data.

This example is pre-configured for STMicroelectronics [STM32H735G-DK](https://www.st.com/en/evaluation-tools/stm32h735g-dk.html) board.

It uses the Ethernet interface to record the data on the host computer.

Test input data:
- test data generated by the application to simulate IMU sensor data

Test output data:
- test data generated by the application to simulate the ML output data

Examples of 7 seconds of recorded data are available in the `./SDS Recordings` subfolder,
which also contains the `.sds.yml` metadata files.

### Configuring stream buffering

The SDS framework implements stream buffering, which must be configured correctly in order
to achive better performance. Therefore, the stream buffer must be large enough to store at least
some data records. If the stream buffer is larger, more data records are buffered before they are
written to the output device. If the stream buffer is smaller, less data is buffered and the data
is written more frequently. In this example, the buffer sizes are selected so that at least **20 data
records** are buffered in order to achieve optimum performance.

The buffer **threshold** specifies a certain value above which the recorded data streams trigger
internal network transmission or writing to a file. The threshold value should therefore be a few
data records below the buffer size.

The following table shows the values configured in the `DataTest` example:

Record size   | Record interval  | Buffer size  | Threshold
:-------------|:-----------------|:-------------|:------------  
360 bytes     | 10 ms            | 8192 bytes   | 7400 bytes    
40 bytes      | 10 ms            | 1536 bytes   | 1400 bytes

**Note**
- The SDS recorder adds an internal header to each data record, which increases the size of
  the recorded data.

### Validation of recorded data

Recorded data can be viewed with the [SDS-View](https://github.com/ARM-software/SDS-Framework/tree/main/utilities/SDS-View)
utility program. This tool reads in the data and
outputs a time-based diagram. You must also provide the tool with a metadata description file
`<name>.sds.yml`.The recordings are processed and decoded based on the description in this file.

### Measuring the CPU load

The idle time is the time during which the CPU does not execute the application code.
This means that it executes the code of the idle thread and waits for an interrupt with
the `WFI` instruction. The CPU load is then calculated as the ratio between the active time
and the measurement interval (3 seconds by default). 

The code for measuring the idle time is located in the `osRtxIdle_Thread`:

```c
__NO_RETURN void osRtxIdleThread(void *argument) {
  uint32_t tick, tick_last = 0U;
  (void)argument;

  for (;;) {
    __WFI();
    tick = osKernelGetTickCount();
    if (tick != tick_last) {
      idle_time += (256 - 256*OS_Tick_GetCount()/OS_Tick_GetInterval());
      tick_last = tick;
    }
  }
}
```

For each new system tick, the code calculates the time required to wait until the next RTOS tick
interrupt and adds it to _idle_time_. The time resolution is the tick interval divided by 256.
Of course, this method does not take into account user interrupts that may be in use. The RTOS
tick interval is normally 1 millisecond, so the measurement accuracy is 1000/256 microseconds.

The `calc_cpu_usage` function calculates the CPU utilization for each 3-second interval. It must
be called periodically at intervals of 10 milliseconds:

```c
static void calc_cpu_usage(void) {
  static uint32_t n_calls;

  if (++n_calls >= 300) {
    cpu_usage = (float)(768000 - idle_time) / 7680.0;
    idle_time = n_calls = 0;
  }
}
```

To see the value of the variable _cpu_usage_, you must enter it in the debugger's watch window
or output it on the debug console.

The concept assumes that the CPU remains in the idle thread until the next RTX-SysTick interrupt.
If other system interrupts are also used, the measurement accuracy is reduced.
