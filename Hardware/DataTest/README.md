# About this application

This is a standalone test application that uses [SDS Recorder](https://github.com/ARM-software/SDS-Framework)
to record test input and output data.

This example is pre-configured for STMicroelectronics [STM32H735G-DK](https://www.st.com/en/evaluation-tools/stm32h735g-dk.html) board.

It uses the Ethernet interface to record the data on the host computer.

Test input data:
- test data generated by the application to simulate IMU sensor data

Test output data:
- test data generated by the application to simulate the ML output data

Examples of 7 seconds of recorded data are available in the `./SDS Recordings` subfolder,
which also contains the `.sds.yml` metadata files.

### Configuring stream buffering

The SDS framework implements stream buffering, which should be properly configured to provide
maximum performance. Therefore, the stream buffer should be large enough to store at least
some data records optimally. If the stream buffer is larger, more data records are buffered
before they are output. If the stream buffer is smaller, less data is buffered and the data is
output more frequently. To achieve optimum performance, the selected value should be close to
the default values.

The buffer **threshold** specifies a certain value above which the recorded data streams trigger
internal network transmission or writing to a file. The threshold value should therefore be a few
data records below the buffer size.

The following table shows the values configured in the `DataTest` example:

Record size   | Record interval  | Buffer size  | Threshold
:-------------|:-----------------|:-------------|:------------  
360 bytes     | 10 ms            | 8192 bytes   | 7400 bytes    
40 bytes      | 10 ms            | 1536 bytes   | 1400 bytes

**Note**
- The SDS recorder adds an internal header to each data record, which increases the size of the recorded data.

### Measuring the CPU load

The idle time is the time during which the CPU does not execute the application code.
This means that it executes the code of the idle thread and waits for an interrupt with
the `WFI` instruction. The CPU load is then calculated as the ratio between the active time
and the measurement interval (3 seconds by default). 

The code for measuring the idle time is located in the `osRtxIdle_Thread`:

```c
__NO_RETURN void osRtxIdleThread(void *argument) {
  uint32_t tick, tick_last = 0U;
  (void)argument;

  for (;;) {
    __WFI();
    tick = osKernelGetTickCount();
    if (tick != tick_last) {
      cnt_idle += (256 - 256*OS_Tick_GetCount()/OS_Tick_GetInterval());
      tick_last = tick;
    }
  }
}
```

For each new system tick, the code calculates the time required to wait until the next RTOS tick
interrupt and adds it to _cnt_idle_. The time resolution is the system interval divided by 256.
Of course, this method does not take into account user interrupts that may be in use. The RTOS
tick interval is normally 1 millisecond, so the measurement accuracy is 1000/256 microseconds.

The `calc_cpu_usage` function calculates the CPU utilization for each 3-second interval. It must
be called periodically at intervals of 10 milliseconds:

```c
static void calc_cpu_usage(void) {
  static uint32_t cnt;

  if (++cnt >= 300) {
    cpu_usage = (float)(768000 - cnt_idle) / 7680.0;
    cnt_idle = cnt = 0;
  }
}
```

To see the value of the variable _cpu_usage_, you must enter it in the debugger's watch window
or output it on the debug console.

The concept assumes that the CPU remains in the idle thread until the next RTX-SysTick interrupt.
If other system interrupts are also used, the measurement accuracy is reduced.
